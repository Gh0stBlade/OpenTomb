
#ifndef FRUSTUM_H
#define FRUSTUM_H

#include <stdint.h>
#include "bullet/LinearMath/btScalar.h"

struct room_s;
struct portal_s;
struct render_s;
struct obb_s;

typedef struct frustum_s
{
    uint16_t            vertex_count;                                           // frustum vertices count (are equal to clip planes count)

    btScalar           *planes;                                                 // clip planes
    btScalar           *vertex;                                                 // frustum vertices
    btScalar           *cam_pos;                                                ///@TODO: delete it!
    btScalar            norm[4];                                                // main frustum clip plane (inv. plane of parent portal)

    uint16_t            parents_count;
    struct frustum_s   *parent;                                                 // by who frustum was generated; parent == NULL is equal generated by camera
    struct frustum_s   *next;                                                   // next frustum in list
}frustum_t, *frustum_p;


class frustumManager
{
public:
    frustumManager(uint32_t buffer_size);
   ~frustumManager();
    
    void reset();
    frustum_p createFrustum();
    
    void splitPrepare(frustum_p frustum, struct portal_s *p);                   // подготовка фрустума к сплиту
    int split_by_plane(frustum_p p, btScalar n[4], btScalar *buf);              // отсечение части портала плоскостью
    void genClipPlanes(frustum_p p, struct camera_s *cam);                      // генерация плоскостей отсечения
    frustum_p portalFrustumIntersect(struct portal_s *portal, frustum_p emitter, struct render_s *render);         // Основная функция для работы с порталами.
private:
    bool m_need_realloc;
    btScalar *alloc(uint32_t size);
    uint32_t m_buffer_size;
    uint32_t m_allocated;
    uint8_t *m_buffer;
};


extern frustumManager engine_frustumManager;


/**
 * Draws wireframe of this frustum.
 *
 * Expected state:
 *  - Vertex array is enabled, color, tex coord, normal disabled
 *  - No vertex buffer object is bound
 *  - Texturing is disabled
 *  - Alpha test is disabled
 *  - Blending is enabled
 *  - Lighting is disabled
 *  - Line width is set to desired width (typically 3.0)
 *  - Current color set to desired color (typically red)
 * Ignored state:
 *  - Currently bound texture.
 *  - Currently bound element buffer.
 *  - Vertex pointer (changes it)
 * Changed state:
 *  - Current position will be arbitrary.
 *  - Vertex pointer will be arbitray.
 */

int Frustum_GetFrustumsCount(struct frustum_s *f);
int Frustum_HaveParent(frustum_p parent, frustum_p frustum);
int Frustum_IsPolyVisible(struct polygon_s *p, struct frustum_s *frustum);
int Frustum_IsAABBVisible(btScalar bbmin[3], btScalar bbmax[3], struct frustum_s *frustum);
int Frustum_IsOBBVisible(struct obb_s *obb, struct frustum_s *frustum);
int Frustum_IsOBBVisibleInRoom(struct obb_s *obb, struct room_s *room);

#endif
